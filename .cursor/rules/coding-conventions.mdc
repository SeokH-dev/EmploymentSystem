---
alwaysApply: true
description: 프로젝트 전체 코딩 컨벤션 및 베스트 프랙티스
---

# 프로젝트 코딩 컨벤션

## 파일 및 디렉토리 네이밍

### 1. 파일 네이밍 규칙
- **컴포넌트 파일**: PascalCase (예: `Home.tsx`, `PersonaSetup.tsx`)
- **훅 파일**: camelCase with `use` prefix (예: `usePersona.ts`, `useJobScrap.ts`)
- **유틸리티 파일**: camelCase (예: `dateUtils.ts`, `stringUtils.ts`)
- **타입 파일**: camelCase (예: `index.ts`)
- **설정 파일**: kebab-case (예: `tailwind.config.js`, `vite.config.ts`)

### 2. 디렉토리 네이밍 규칙
- **소문자와 하이픈 사용** (예: `src/components/ui/`, `src/api/`)
- **기능별 그룹화** (예: `components/`, `hooks/`, `types/`, `utils/`)

## 변수 및 함수 네이밍

### 1. 변수 네이밍
```typescript
// ✅ 좋은 예
const currentPersona = useState<PersonaResponse | null>(null);
const scrapedJobs = useState<Set<string>>(new Set());
const isNewUser = useState(false);

// ❌ 나쁜 예
const current_persona = useState(null);
const scrapedJobs = useState([]);
const is_new_user = useState(false);
```

### 2. 함수 네이밍
```typescript
// ✅ 좋은 예 - 동사로 시작하는 명확한 함수명
const handlePersonaComplete = async (persona: PersonaResponse) => { };
const handleJobSelect = (jobId: string) => { };
const handleToggleScrap = (jobId: string) => { };
const navigateTo = (page: Page, source?: NavigationSource) => { };

// ❌ 나쁜 예 - 모호한 함수명
const doSomething = () => { };
const process = (data: any) => { };
const handle = () => { };
```

### 3. 이벤트 핸들러 네이밍
- `handle` + `Action` 패턴 사용
- `on` + `Action` 패턴은 Props로 전달되는 콜백에 사용

```typescript
// ✅ 좋은 예
const handleSubmit = () => { };
const handleClick = () => { };
const handleChange = () => { };

// Props로 전달되는 콜백
interface ButtonProps {
  onClick: () => void;
  onSubmit: (data: FormData) => void;
}
```

## Import/Export 규칙

### 1. Import 순서
```typescript
// ✅ 좋은 예 - import 순서
// 1. React 관련
import { useState, useEffect } from 'react';
import { createRoot } from 'react-dom/client';

// 2. 외부 라이브러리
import axios from 'axios';
import { Toaster } from 'sonner';

// 3. 내부 컴포넌트
import { Home } from './components/Home';
import { Auth } from './components/Auth';

// 4. 타입
import type { Page, PersonaResponse } from './types';

// 5. 유틸리티
import { cn } from './lib/utils';
```

### 2. Export 패턴
```typescript
// ✅ 좋은 예 - 명명된 export 우선 사용
export function Home() { }
export const Button = () => { };
export type { Page, PersonaResponse };

// 기본 export는 메인 컴포넌트에만 사용
export default function App() { }
```

## 주석 및 문서화

### 1. JSDoc 주석
```typescript
// ✅ 좋은 예 - 복잡한 함수에 JSDoc 사용
/**
 * 페르소나를 생성하고 현재 페르소나로 설정합니다.
 * @param data - 페르소나 생성에 필요한 데이터
 * @returns 생성된 페르소나 정보
 * @throws {Error} API 요청 실패 시 에러 발생
 */
const createPersona = async (data: PersonaData): Promise<PersonaResponse> => {
  // 구현
};
```

### 2. 인라인 주석
```typescript
// ✅ 좋은 예 - 복잡한 로직에 설명 추가
const handleInterviewStart = (session: InterviewSession) => {
  setCurrentInterviewSession(session);
  // 음성 면접 여부에 따라 다른 페이지로 라우팅
  if (session.useVoiceInterview) {
    setCurrentPage("voice-interview-questions");
  } else {
    setCurrentPage("interview-questions");
  }
};
```

## 에러 처리 컨벤션

### 1. 에러 메시지
```typescript
// ✅ 좋은 예 - 사용자 친화적인 에러 메시지
const errorMessages = {
  NETWORK_ERROR: '네트워크 연결을 확인해주세요.',
  AUTH_REQUIRED: '로그인이 필요합니다.',
  VALIDATION_ERROR: '입력 정보를 확인해주세요.',
  SERVER_ERROR: '서버 오류가 발생했습니다. 잠시 후 다시 시도해주세요.',
};
```

### 2. 에러 로깅
```typescript
// ✅ 좋은 예 - 구조화된 에러 로깅
const handleApiError = (error: unknown, context: string) => {
  console.error(`[${context}] API Error:`, {
    message: error instanceof Error ? error.message : 'Unknown error',
    stack: error instanceof Error ? error.stack : undefined,
    timestamp: new Date().toISOString(),
  });
};
```

## 코드 구조 패턴

### 1. 컴포넌트 구조 순서
```typescript
// ✅ 좋은 예 - 컴포넌트 내부 구조 순서
export function ComponentName() {
  // 1. 상태 선언
  const [state, setState] = useState();
  
  // 2. 커스텀 훅 사용
  const { data, loading } = useCustomHook();
  
  // 3. 이벤트 핸들러
  const handleClick = () => { };
  
  // 4. 사이드 이펙트
  useEffect(() => { }, []);
  
  // 5. 렌더링
  return <div>Content</div>;
}
```

### 2. 조건부 렌더링 패턴
```typescript
// ✅ 좋은 예 - 명확한 조건부 렌더링
return (
  <div>
    {loading && <Spinner />}
    {error && <ErrorMessage message={error} />}
    {data && <DataDisplay data={data} />}
    {!loading && !error && !data && <EmptyState />}
  </div>
);
```

## 성능 고려사항

### 1. 불필요한 리렌더링 방지
```typescript
// ✅ 좋은 예 - useCallback으로 함수 메모이제이션
const handleSubmit = useCallback((data: FormData) => {
  onSubmit(data);
}, [onSubmit]);

// ✅ 좋은 예 - useMemo로 계산 메모이제이션
const filteredData = useMemo(() => {
  return data.filter(item => item.active);
}, [data]);
```

### 2. 컴포넌트 분리
```typescript
// ✅ 좋은 예 - 큰 컴포넌트를 작은 단위로 분리
const PersonaCard = ({ persona }: { persona: PersonaResponse }) => {
  return (
    <Card>
      <PersonaCardHeader persona={persona} />
      <PersonaCardContent persona={persona} />
      <PersonaCardActions persona={persona} />
    </Card>
  );
};
```

## 테스트 고려사항

### 1. 테스트 가능한 코드 작성
```typescript
// ✅ 좋은 예 - 순수 함수로 분리
const calculateMatchScore = (persona: PersonaResponse, job: Job): number => {
  // 계산 로직
  return score;
};

// ✅ 좋은 예 - 의존성 주입
const usePersonaService = (apiClient: ApiClient) => {
  const createPersona = async (data: PersonaData) => {
    return apiClient.post('/personas', data);
  };
  
  return { createPersona };
};
```