---
globs: src/api/**/*,src/hooks/**/*,src/context/**/*
description: API 통합 및 데이터 관리 패턴 가이드
---

# API 통합 및 데이터 관리 가이드

## API 클라이언트 구조

### 1. 중앙화된 API 클라이언트
[src/api/apiClient.ts](mdc:src/api/apiClient.ts)에서 Axios 기반 API 클라이언트를 관리합니다.

```typescript
// ✅ 좋은 예 - 타입 안전한 API 클라이언트
import axios from 'axios';

const apiClient = axios.create({
  baseURL: process.env.VITE_API_BASE_URL,
  timeout: 10000,
});

// 요청 인터셉터
apiClient.interceptors.request.use((config) => {
  const token = localStorage.getItem('authToken');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

// 응답 인터셉터
apiClient.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      // 인증 실패 처리
      localStorage.removeItem('authToken');
      window.location.href = '/login';
    }
    return Promise.reject(error);
  }
);
```

### 2. API 함수 타입 정의
```typescript
// ✅ 좋은 예 - 명확한 API 함수 시그니처
export const createPersona = async (data: PersonaData): Promise<PersonaResponse> => {
  const response = await apiClient.post<PersonaResponse>('/personas', data);
  return response.data;
};

export const getJobRecommendations = async (personaId: string): Promise<JobRecommendationResponse> => {
  const response = await apiClient.get<JobRecommendationResponse>(`/personas/${personaId}/recommendations`);
  return response.data;
};
```

## 커스텀 훅 패턴

### 1. 데이터 페칭 훅
[src/hooks/usePersona.ts](mdc:src/hooks/usePersona.ts)와 [src/hooks/useJobScrap.ts](mdc:src/hooks/useJobScrap.ts)에서 비즈니스 로직을 캡슐화합니다.

```typescript
// ✅ 좋은 예 - 커스텀 훅 구조
export function usePersona() {
  const [personas, setPersonas] = useState<PersonaResponse[]>([]);
  const [currentPersona, setCurrentPersona] = useState<PersonaResponse | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const createPersona = async (data: PersonaData): Promise<PersonaResponse> => {
    setLoading(true);
    setError(null);
    try {
      const response = await createPersonaAPI(data);
      setPersonas(prev => [...prev, response]);
      setCurrentPersona(response);
      return response;
    } catch (err) {
      setError(err instanceof Error ? err.message : '페르소나 생성에 실패했습니다.');
      throw err;
    } finally {
      setLoading(false);
    }
  };

  return {
    personas,
    currentPersona,
    loading,
    error,
    createPersona,
    selectPersona: setCurrentPersona,
  };
}
```

### 2. 상태 관리 훅
```typescript
// ✅ 좋은 예 - 로컬 상태와 서버 상태 분리
export function useJobScrap() {
  const [scrapedJobs, setScrapedJobs] = useState<Set<string>>(new Set());

  const toggleScrap = async (jobId: string, personaId: string, userId: string) => {
    try {
      const isScraped = scrapedJobs.has(jobId);
      if (isScraped) {
        await unscrapJobAPI(jobId, personaId, userId);
        setScrapedJobs(prev => {
          const newSet = new Set(prev);
          newSet.delete(jobId);
          return newSet;
        });
      } else {
        await scrapJobAPI(jobId, personaId, userId);
        setScrapedJobs(prev => new Set(prev).add(jobId));
      }
    } catch (error) {
      console.error('스크랩 토글 실패:', error);
      throw error;
    }
  };

  const getScrapedJobs = (personaId?: string): Set<string> => {
    return scrapedJobs;
  };

  return {
    scrapedJobs,
    toggleScrap,
    getScrapedJobs,
  };
}
```

## Context API 패턴

### 1. 인증 상태 관리
[src/context/AuthContext.tsx](mdc:src/context/AuthContext.tsx)에서 전역 인증 상태를 관리합니다.

```typescript
// ✅ 좋은 예 - Context Provider 구조
interface AuthContextType {
  user: User | null;
  loading: boolean;
  login: (email: string, password: string) => Promise<void>;
  logout: () => void;
  signup: (userData: SignupData) => Promise<void>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);

  const login = async (email: string, password: string) => {
    setLoading(true);
    try {
      const response = await loginAPI(email, password);
      setUser(response.user);
      localStorage.setItem('authToken', response.token);
    } catch (error) {
      throw error;
    } finally {
      setLoading(false);
    }
  };

  const logout = () => {
    setUser(null);
    localStorage.removeItem('authToken');
  };

  return (
    <AuthContext.Provider value={{ user, loading, login, logout, signup }}>
      {children}
    </AuthContext.Provider>
  );
}
```

## 에러 처리 패턴

### 1. API 에러 처리
```typescript
// ✅ 좋은 예 - 구조화된 에러 처리
const handleApiError = (error: unknown): string => {
  if (axios.isAxiosError(error)) {
    if (error.response?.status === 400) {
      return '잘못된 요청입니다.';
    } else if (error.response?.status === 401) {
      return '인증이 필요합니다.';
    } else if (error.response?.status === 500) {
      return '서버 오류가 발생했습니다.';
    }
    return error.response?.data?.message || '알 수 없는 오류가 발생했습니다.';
  }
  return '네트워크 오류가 발생했습니다.';
};
```

### 2. 컴포넌트 레벨 에러 처리
```typescript
// ✅ 좋은 예 - 컴포넌트에서 에러 상태 관리
const [error, setError] = useState<string | null>(null);

const handleSubmit = async (data: FormData) => {
  try {
    setError(null);
    await submitData(data);
    // 성공 처리
  } catch (err) {
    setError(handleApiError(err));
  }
};

return (
  <div>
    {error && (
      <Alert variant="destructive">
        <AlertDescription>{error}</AlertDescription>
      </Alert>
    )}
    {/* 폼 컨텐츠 */}
  </div>
);
```

## 데이터 동기화 패턴

### 1. 낙관적 업데이트
```typescript
// ✅ 좋은 예 - 낙관적 업데이트 패턴
const toggleScrap = async (jobId: string) => {
  const isScraped = scrapedJobs.has(jobId);
  
  // 즉시 UI 업데이트
  setScrapedJobs(prev => {
    const newSet = new Set(prev);
    if (isScraped) {
      newSet.delete(jobId);
    } else {
      newSet.add(jobId);
    }
    return newSet;
  });

  try {
    // 서버에 요청
    await toggleScrapAPI(jobId);
  } catch (error) {
    // 실패 시 롤백
    setScrapedJobs(prev => {
      const newSet = new Set(prev);
      if (isScraped) {
        newSet.add(jobId);
      } else {
        newSet.delete(jobId);
      }
      return newSet;
    });
    throw error;
  }
};
```

### 2. 데이터 무효화
```typescript
// ✅ 좋은 예 - 데이터 새로고침 패턴
const refreshPersonas = async () => {
  setLoading(true);
  try {
    const updatedPersonas = await getPersonasAPI();
    setPersonas(updatedPersonas);
  } catch (error) {
    console.error('페르소나 목록 새로고침 실패:', error);
  } finally {
    setLoading(false);
  }
};
```

## 성능 최적화

### 1. 요청 디바운싱
```typescript
// ✅ 좋은 예 - 검색 요청 디바운싱
const [searchTerm, setSearchTerm] = useState('');
const [debouncedSearchTerm] = useDebounce(searchTerm, 300);

useEffect(() => {
  if (debouncedSearchTerm) {
    searchJobs(debouncedSearchTerm);
  }
}, [debouncedSearchTerm]);
```

### 2. 캐싱 전략
```typescript
// ✅ 좋은 예 - 간단한 메모리 캐싱
const cache = new Map<string, { data: any; timestamp: number }>();
const CACHE_DURATION = 5 * 60 * 1000; // 5분

const getCachedData = async <T>(key: string, fetcher: () => Promise<T>): Promise<T> => {
  const cached = cache.get(key);
  if (cached && Date.now() - cached.timestamp < CACHE_DURATION) {
    return cached.data;
  }
  
  const data = await fetcher();
  cache.set(key, { data, timestamp: Date.now() });
  return data;
};
```