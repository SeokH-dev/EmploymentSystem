---
globs: *.tsx,*.jsx
---

# React 컴포넌트 작성 및 구조 가이드

## 컴포넌트 구조 패턴

### 1. 컴포넌트 파일 구조
```typescript
// ✅ 좋은 예 - 컴포넌트 내부 구조 순서
export function ComponentName() {
  // 1. 상태 선언
  const [state, setState] = useState();
  
  // 2. 커스텀 훅 사용
  const { data, loading } = useCustomHook();
  
  // 3. 이벤트 핸들러
  const handleClick = () => { };
  
  // 4. 사이드 이펙트
  useEffect(() => { }, []);
  
  // 5. 렌더링
  return <div>Content</div>;
}
```

### 2. Props 인터페이스 정의
- 모든 Props는 명확한 타입 정의
- 옵셔널 Props는 `?` 사용
- 이벤트 핸들러는 명확한 시그니처 정의

### 3. 컴포넌트 분리 원칙
- 단일 책임 원칙: 하나의 컴포넌트는 하나의 기능만 담당
- 재사용성: 공통 UI 패턴은 별도 컴포넌트로 분리
- 복잡한 컴포넌트는 작은 단위로 분해

## 상태 관리 패턴

### 1. 로컬 상태 vs 전역 상태
```typescript
// ✅ 좋은 예 - 로컬 상태 사용
const [isLoading, setIsLoading] = useState(false);
const [formData, setFormData] = useState<FormData>({});

// ✅ 좋은 예 - 전역 상태는 Context나 커스텀 훅 사용
const { currentPersona, selectPersona } = usePersona();
```

### 2. 상태 업데이트 패턴
```typescript
// ✅ 좋은 예 - 함수형 업데이트
setItems(prev => [...prev, newItem]);
setCount(prev => prev + 1);

// ✅ 좋은 예 - 복잡한 상태 업데이트
setFormData(prev => ({
  ...prev,
  [field]: value
}));
```

## 이벤트 핸들링

### 1. 이벤트 핸들러 네이밍
```typescript
// ✅ 좋은 예 - 명확한 핸들러 이름
const handleSubmit = (e: FormEvent) => { };
const handleJobSelect = (jobId: string) => { };
const handleToggleScrap = (jobId: string) => { };

// ❌ 나쁜 예 - 모호한 핸들러 이름
const handle = () => { };
const onClick = () => { };
```

### 2. 이벤트 핸들러 구현
```typescript
// ✅ 좋은 예 - 에러 처리 포함
const handleSubmit = async (data: FormData) => {
  try {
    setLoading(true);
    await submitData(data);
    // 성공 처리
  } catch (error) {
    setError(error.message);
  } finally {
    setLoading(false);
  }
};
```

## 조건부 렌더링

### 1. 명확한 조건부 렌더링
```typescript
// ✅ 좋은 예
return (
  <div>
    {loading && <Spinner />}
    {error && <ErrorMessage message={error} />}
    {data && <DataDisplay data={data} />}
    {!loading && !error && !data && <EmptyState />}
  </div>
);

// ❌ 나쁜 예 - 복잡한 조건
return (
  <div>
    {loading ? <Spinner /> : error ? <ErrorMessage /> : data ? <DataDisplay /> : <EmptyState />}
  </div>
);
```

## 성능 최적화

### 1. 불필요한 리렌더링 방지
```typescript
// ✅ 좋은 예 - useCallback으로 함수 메모이제이션
const handleSubmit = useCallback((data: FormData) => {
  onSubmit(data);
}, [onSubmit]);

// ✅ 좋은 예 - useMemo로 계산 메모이제이션
const filteredData = useMemo(() => {
  return data.filter(item => item.active);
}, [data]);
```

### 2. 컴포넌트 분리
```typescript
// ✅ 좋은 예 - 큰 컴포넌트를 작은 단위로 분리
const PersonaCard = ({ persona }: { persona: PersonaResponse }) => {
  return (
    <Card>
      <PersonaCardHeader persona={persona} />
      <PersonaCardContent persona={persona} />
      <PersonaCardActions persona={persona} />
    </Card>
  );
};
```

## 에러 처리

### 1. 컴포넌트 레벨 에러 처리
```typescript
// ✅ 좋은 예 - 에러 상태 관리
const [error, setError] = useState<string | null>(null);

const handleSubmit = async (data: FormData) => {
  try {
    setError(null);
    await submitData(data);
  } catch (err) {
    setError(err instanceof Error ? err.message : '알 수 없는 오류가 발생했습니다.');
  }
};

return (
  <div>
    {error && (
      <Alert variant="destructive">
        <AlertDescription>{error}</AlertDescription>
      </Alert>
    )}
    {/* 폼 컨텐츠 */}
  </div>
);
```

## 접근성 (Accessibility)

### 1. 시맨틱 HTML 사용
```typescript
// ✅ 좋은 예
<main>
  <section>
    <h1>페이지 제목</h1>
    <article>
      <h2>섹션 제목</h2>
    </article>
  </section>
</main>

// ❌ 나쁜 예
<div>
  <div>
    <div>페이지 제목</div>
  </div>
</div>
```

### 2. 키보드 접근성
```typescript
// ✅ 좋은 예 - 키보드 이벤트 처리
const handleKeyDown = (e: KeyboardEvent) => {
  if (e.key === 'Enter' || e.key === ' ') {
    handleClick();
  }
};
```